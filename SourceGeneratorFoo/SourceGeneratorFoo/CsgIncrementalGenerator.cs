using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SourceGeneratorFoo;

[Generator(LanguageNames.CSharp)]
public class CsgIncrementalGenerator : IIncrementalGenerator
{
    private Dictionary<string,string> _keyDictionary = new ()
    {
        {"引用命名空间 ","using "},
        {"定义命名空间 ","namespace "},
        {"类型 ","class "},
        {"公开的 ","public "},
        {"静态的 ","static "},
        {"无返回值类型的 ","void "},
    };
    
    private const string DefaultLogSourceCode = @"// <auto-generated/>
using System;
namespace 系统;

static class 日志
{
    public static void 输出一行文本(string 文本)
    {
        Console.WriteLine(文本);
    }
}
";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add 日志 to compilation
        context.RegisterPostInitializationOutput(ctx=> ctx.AddSource("DefaultLog.g.cs", SourceText.From(DefaultLogSourceCode, Encoding.UTF8)));
        
        var provider = context.AdditionalTextsProvider
            .Where(x => Path.GetFileName(x.Path) == "这是测试类型.csg");
        
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private void GenerateCode(SourceProductionContext context, AdditionalText additionalText)
    {
        var sb = new StringBuilder();
        
        var lines = additionalText.GetText(context.CancellationToken)?.Lines;
        if (lines == null) return;
        foreach (var textLine in lines.Select(line => line.ToString()))
        {
            var text = _keyDictionary.Aggregate(textLine, (current, kv) => current.Replace(kv.Key, kv.Value));
            sb.AppendLine(text);
        }
        
        context.AddSource($"{Path.GetFileNameWithoutExtension(additionalText.Path)}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}